# 使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方

此问题可以使用类似Leetcode中搜索旋转排序数组的思路.

使用二分法时, 一个中点的两侧必有一侧有序的. 通过判断中点与右边界的值可以得出哪一侧无序. 通过不断逼近无序侧可以得到无序位置.
```
def findMin(self, nums: List[int]) -> int:
    left = 0
    right = len(nums) - 1
    while left < right:
        mid = (left+right)//2
        if nums[mid] > nums[right]:
            left = mid+1
        else:
            right = mid
    return nums[left]
```
# 学习笔记
## BFS & DFS
这一部分主要是记忆理解它们的代码模板. 其中, DFS可以使用栈或者递归来实现, BFS则是使用队列实现.

## 贪心算法
贪心算法本身概念简单, 就是靠不断得到局部最优解以得到全局最优解. 其与回溯, 动态规划类似, 但不同的地方在于贪心算法没有撤回.

贪心算法可以从前往后, 或者从后往前(即从结果反推). 解题时应注意开拓思路.

## 二分查找
二分查找也主要是记忆代码模板, 使用时注意边界的处理.
